practice 1
```C
#include <stdio.h>

int min(int num[], int array_size);
int max(int num[], int array_size);

void main() {
	int num[] = { 8, 54, 11, -45, 43, 26, 66, 12, 13, 65 };
	int array_size = sizeof(num) / sizeof(int);
	int i;

	printf("배열 값 :");
	for (i = 0; i < array_size; i++) {
		printf("%d ", num[i]);
	}

	printf("\n최대값 : %d\n", max(num, array_size));
	printf("최소값 : %d\n", min(num, array_size));

}
int max(int num[], int array_size) {
	int max = num[0], i;
	for (i = 0; i < array_size; i++) {
		if (num[i] > max) {
			max = num[i];
		}
	}
	return max;
}

int min(int num[], int array_size) {
	int min = num[0], i;
	for (i = 0; i < array_size; i++) {
		if (num[i] < min) {
			min = num[i];
		}
	}
	return min;
}
```

practice 2
```C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


int main() {
	char input_str[100] = { "\0" };
	char result_str[100] = { "\0" };
	int num;
	int length, i;
	int str_to_int;
	printf("사용할 문자열을 입력하시오 : ");
	gets(input_str);
	length = strlen(input_str);
	while (1) {
		printf("----------------------- 문자열 처리 프로그램-----------------------\n");
		printf("1. 소문자 to 대문자                    \n");
		printf("2. 대문자 to 소문자                    \n");
		printf("3. 문자   to 숫자 후 300과 더하기      \n");
		printf("4. 문자를 거꾸로 출력                  \n");
		printf("0. 프로그램 종료                       \n");
		printf("-------------------------------------------------------------------\n");
		printf("원하시는 처리를 숫자로 입력 해주세요:");
		scanf_s("%d", &num);
		fflush(stdin);

		switch (num) {
		case 1:
			for (i = 0; i < length; i++) {
				if (input_str[i] <= 122 && input_str[i] >= 97)		result_str[i] = input_str[i] - 32;
				else result_str[i] = input_str[i];
			}
			printf("소문자 to 대문자 : %s\n", result_str);
			break;
		case 2:
			for (i = 0; i < length; i++) {
				if (input_str[i] <= 90 && input_str[i] >= 65)		result_str[i] = input_str[i] + 32;
				else result_str[i] = input_str[i];
			}
			printf("대문자 to 소문자 : %s\n", result_str);
			break;
		case 3:
			str_to_int = atoi(input_str);
			printf("%d + 300 = %d\n", str_to_int, str_to_int + 300);
			break;
		case 4:
			for (i = 0; i < length; i++) {
				result_str[i] = input_str[length - 1 - i];
			}
			printf("%s\n", result_str);
			break;
		case 0:
			return 0;
		default:
			printf("default");
			break;
		}
	}
}
```
practice 3
```C
#include <stdio.h>
#include <time.h> 
#include <Windows.h>

int randNumber(int[]); 

void main() {
	int i, j, z, question[3] = { 0 }, answer[3] = { 0 }, sbo[3] = { 0 };
	int limit = 9;

	while (1) {
		printf("문제를 생성 중입니다....\r");
		randNumber(question);		
		printf("\n");
		printf("%d %d %d\n", question[0], question[1], question[2]);

		for (i = 6; i >= 0; i--) {
			printf("%d번 남았습니다.. 숫자를 x x x와 같이 입력해주세요 :", i + 1);
			scanf_s("%d %d %d", &answer[0], &answer[1], &answer[2]);

			if (answer[0] == answer[1] || answer[0] == answer[2] || answer[1] == answer[2]) {
				printf("같은 숫자를 입력하시면 안됩니다 다시 입력 해주세요.\n");
				if (i != 7)	i = i + 1;
				continue;
			}

			if (answer[0] > limit || answer[1] > limit || answer[2] > limit) {
				printf("0-9 사이의 숫자를 입력해 주시기 바랍니다. 다시 입력 해주세요.\n");
				if (i != 7)	i = i + 1;
				continue;
			}

			for (j = 0; j < 3; j++) {
				if (question[j] == answer[j]) {
					sbo[0]++;
				}  //스트라이크 
				else {
					for (z = 0; z < 3; z++) {
						if (j == z) {
							continue;
						}
						else if (question[j] == answer[z]) {
							sbo[1]++;
						}  //볼 
					}
				}
			}

			sbo[2] = 3 - (sbo[0] + sbo[1]);
			printf("결과 : %d %d %d \t S: %d, B: %d, O:%d \n", answer[0], answer[1], answer[2], sbo[0], sbo[1], sbo[2]);
			if (sbo[0] == 3) {
				printf("문제를 맞히셨습니다 ^^\n");
				break;
			}
			if (i == 0) {
				printf("답을 못맞추셨군요.... 답은 %d %d %d 입니다.\n", question[0], question[1], question[2]);
			}
			sbo[0] = sbo[1] = sbo[2] = 0;
		}
	}
}

int randNumber(int q[]) {
	int i = 0, j = 0;
	int size = sizeof(q) / sizeof(int);
	srand(time(NULL));
	for (i = 0; i < size; i++) {
		q[i] = rand() % 9;
		for (j = 0; j < i; j++) {
			if (q[i] == q[j]) {
				i--;
				break;
			}
		}
	}
	return rand() % 9;
} 
```
practice 4
```C
#include <stdio.h>

void main() {
	int A[2][2] = { {5,7}, {3,2} };
	int B[2][1] = { {2}, {4} };
	int result[2][1], sum, i, j, k;

	printf("행렬 A*B 구하기\n\n");
	for (i = 0; i < 2; i++) {
		printf("│");
		for (j = 0; j < 2; j++) {
			printf(" %d ", A[i][j]);
		}
		printf("│");
		printf("\t│%d│", B[i][0]);
		printf("\n");
		if (i == 0) {
			printf("│      │  *   │ │\n");
		}
	}
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 1; j++) {
			sum = 0;
			for (k = 0; k < 2; k++) {
				sum += A[i][k] * B[k][j];
			}
			result[i][j] = sum;
		}
	}
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 1; j++) {
			printf("\t\t     │%d│ ", result[i][j]);
		}
		printf("\n");
		if (i == 0) {
			printf("\t\t   = │  │\n");
		}
	}
}
```
practice 5
```C
#include<stdio.h>
typedef struct point {
	int xpos;
	int ypos;
}Point;
typedef struct rectangle {
	Point LeftUp;
	Point RightDown;
}Rectangle;

int main(void) {
	Rectangle rec ;
	int Istrue = 1;
	printf("좌 상단 좌표 입력(x y): ");
	scanf_s("%d %d", &rec.LeftUp.xpos, &rec.LeftUp.ypos);
	do {
		printf("우 하단 좌표 입력(x y): ");
		scanf_s("%d %d", &rec.RightDown.xpos, &rec.RightDown.ypos);
		if (rec.LeftUp.xpos < rec.RightDown.xpos && rec.LeftUp.ypos > rec.RightDown.ypos)
			Istrue = 0;
		else {
			printf("잘못입력하셨습니다. \n");
		}
	} while (Istrue);

	int area = (rec.RightDown.xpos - rec.LeftUp.xpos) * (rec.LeftUp.ypos - rec.RightDown.ypos);

	printf("입력하신 좌표의 사각형 넓이: %d\n", area);
	printf("[%3d, %3d] [%3d, %3d] \n", rec.LeftUp.xpos, rec.LeftUp.ypos, rec.RightDown.xpos, rec.LeftUp.ypos);
	printf("[%3d, %3d] [%3d, %3d] \n", rec.LeftUp.xpos, rec.RightDown.ypos, rec.RightDown.xpos, rec.RightDown.ypos);

	return 0;
}
```
practice 6
```C
#include <stdio.h>
#include <string.h>

void main() {
	char str[] = "This study is toward interactive dynamic mapping on web based on open source.\
 Among available interactive mapping of open source libraries, D3.js was chosen.\
 It is a JavaScript library with capability to bind arbitrary data and provides \
 open source mapping framework. Analysis of geo-statistical data is designed using R,\
 a package and programming language for statistical data analysis. \
 This work implemented an integrated user interface with these separate frameworks, \
 and provides a mobile web app application for client sides.";
	puts(str);
	int len = sizeof(str) / sizeof(str[0]);
	printf("str 문자열의 길이는 : %d \n", strlen(str));
	printf("str 문자열의 , 띄어쓰기 갯수는 : %d \n", charCount(str, len));

}

int charCount(char str[], int len) {
	int result=0;
	for (int i = 0; i < len; i++) {
		if (str[i] == ' ') result++;
	}
	return result;
}
```
practice 7
```C
#include <stdio.h>
#include <Windows.h>

typedef struct point {
	int x;
	int y;
}Point;
typedef struct line {
	Point startXY;
	Point endXY;
}Line;
typedef struct circle {
	Point center;
	float radius;
}Circle;
void shapePrint(Line* lptr, int cur_line, Circle* cptr, int cur_cir);
void ClearLineFromReadBuffer(void);

int main(void) {
	Line lines[10];
	Circle circles[10];
	int input, cur_line = 0, cur_cir = 0;

	while (1) {
		printf("-----------------------------------\n");
		printf("1. 라인 입력\n");
		printf("2. 원 입력\n");
		printf("3. 저장된 도형 출력\n");
		printf("4. 종료\n");
		printf("-----------------------------------\n");
		printf("원하는 번호를 입력하시오[저장된 도형 (라인:%d, 원: %d)]\n", cur_line, cur_cir);
		scanf_s("%d", &input);
		switch (input) {
		case 1:
			printf("시작점(x,y) 입력 예)0 0 :"); scanf_s("%d %d", &lines[cur_line].startXY.x, &lines[cur_line].startXY.y);
			printf("끝점(x,y) 입력 예)1 1 :"); scanf_s("%d %d", &lines[cur_line].endXY.x, &lines[cur_line].endXY.y);
			cur_line++;
			break;
		case 2:
			printf("중심점(x,y) 입력 예)0 0 :"); scanf_s("%d %d", &circles[cur_cir].center.x, &circles[cur_cir].center.y);
			printf("반지름 입력 예)5 :"); scanf_s("%f", &circles[cur_cir].radius);
			cur_cir++;
			break;
		case 3:
			shapePrint(lines, cur_line, circles, cur_cir);
			break;
		case 4:
			return 0;
		default:
			printf("원하는 번호가 없습니다\n");
		}
		system("cls");
	}

}

void ClearLineFromReadBuffer(void) {
	while (getchar() != '\n');
}
void shapePrint(Line* lptr, int cur_line, Circle* cptr, int cur_cir) {
	int i;
	printf("입력한 선 출력\n");
	for (i = 0; i < cur_line; i++) {
		printf("  %d번째 선 : 시작점(%d, %d) 끝점(%d, %d) \n", i + 1, lptr[i].startXY.x, lptr[i].startXY.y, lptr[i].endXY.x, lptr[i].endXY.y);
	}
	printf("입력한 원 출력\n");
	for (i = 0; i < cur_cir; i++) {
		printf("  %d번째 원 : 중심점(%d, %d) 반지름 :%f \n", i + 1, cptr[i].center.x, cptr[i].center.y, cptr[i].radius);
	}
	puts("메뉴로돌아가려면 엔터를 누르시기 바랍니다");
	ClearLineFromReadBuffer();
	getchar();
}
```
practice 8
```C
#include <stdio.h>


void swap(int* a, int* b) {
	int tmp = *b;
	*b = *a;
	*a = tmp;
}

int main() {
	int a = 5, b = 7;

	printf("a: %d, b: %d\n", a, b);

	swap(&a, &b);

	printf("a: %d, b: %d", a, b);



}
```
practice 9
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef char element;
#define MAX_STACK_SIZE 100


typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
} StackType;

//스택 초기화 -1, 비어있음으로 판별
void init_stack(StackType* s) {
	s->top = -1;
}

//스택 비어있는지 확인 (-1인지)
int is_empty(StackType* s) {
	return (s->top == -1);
}

//스택이 꽉 차 있는지 (MAX_STACK_SIZE -1 과 같으면)
int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

//스택에 데이터 삽입
void push(StackType* s, element item) {
	if (is_full(s)) {//꽉 차 있는지 검색
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item; //삽입 후 top 부분 +1
}

//스택 데이터 추출 (맨 위부터)
element pop(StackType* s) {
	if (is_empty(s)) {//공백인지 검색
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];//그냥 맨 위를 아래로)
}

element peek(StackType* s) {
	if (is_empty(s)) {//빈 공간인지 확인
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];//peek는 데이터를 확인함으로 그냥 top 데이터 확인
}

int main(void) {
	char name[] = "Kwangseob Kim";
	StackType s;

	init_stack(&s);
	for (int i = 0; i < strlen(name); i++) {
		push(&s, name[i]);
	}

	while(!is_empty(&s)){
		printf("%c", pop(&s));
	}

	return 0;
}
```
practice 10
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef char element;
#define MAX_STACK_SIZE 100

typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
} StackType;
void init_stack(StackType* s) {
	s->top = -1;
}

int is_empty(StackType* s) {
	return (s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

void push(StackType* s, element item) {
	if (is_full(s)) {
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];
}

element peek(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];
}
 
int main(void) {
	StackType s;
	char string[100];

	init_stack(&s);
	printf("문자열을 입력해주세요(소문자):");
	gets_s(string, 100);

	int cnt = 1;
	push(&s, string[0]);
	for (int i = 1; i < strlen(string); i++) {
		char c = peek(&s);
		if (string[i] == c) {
			cnt++;
			push(&s, string[i]);
		}
		else {
			printf("%d", cnt);
			printf("%c", c);
			init_stack(&s);
			cnt = 1;
			push(&s, string[i]);
		}
	}	
	printf("%d", cnt);
	printf("%c", pop(&s));

	return 0;
}
```
practice 11
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef char element;
#define MAX_STACK_SIZE 100


typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
} StackType;

//스택 초기화 -1, 비어있음으로 판별
void init_stack(StackType* s) {
	s->top = -1;
}

//스택 비어있는지 확인 (-1인지)
int is_empty(StackType* s) {
	return (s->top == -1);
}

//스택이 꽉 차 있는지 (MAX_STACK_SIZE -1 과 같으면)
int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

//스택에 데이터 삽입
void push(StackType* s, element item) {
	if (is_full(s)) {//꽉 차 있는지 검색
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item; //삽입 후 top 부분 +1
}

//스택 데이터 추출 (맨 위부터)
element pop(StackType* s) {
	if (is_empty(s)) {//공백인지 검색
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];//그냥 맨 위를 아래로)
}

element peek(StackType* s) {
	if (is_empty(s)) {//빈 공간인지 확인
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];//peek는 데이터를 확인함으로 그냥 top 데이터 확인
}

int eval(char exp[]) {
	int op1, op2, value, i = 0;
	int len = strlen(exp);
	char ch;
	StackType s;

	init_stack(&s);
	for (i = 0; i < len; i++) {
		ch = exp[i];
		if (ch != '+' && ch != '-' && ch != '*' && ch != '/') {
			value = ch - '0';	// 입력이 피연산자이면 char 다보니 0을 빼면 숫자가 나옴
			push(&s, value);
		}
		else {	//연산자이면 피연산자를 스택에서 제거
			op2 = pop(&s);	//연산자는 피연산자가 2개가 있어야 처리 가능하므로..
			op1 = pop(&s);	
			switch (ch) { //연산을 수행하고 스택에 저장 
			case '+': push(&s, op1 + op2); break;
			case '-': push(&s, op1 - op2); break;
			case '*': push(&s, op1 * op2); break;
			case '/': push(&s, op1 / op2); break;
			}
		}
	}
	return pop(&s);
}

int main(void) {
	int result;
	printf("후위표기식은 82/3-32*+\n");
	result = eval("82/3-32*+");
	printf("결과값은 %d\n", result);
	return 0;
}
```
practice 12
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef int element;
#define MAX_STACK_SIZE 100


typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
} StackType;

//스택 초기화 -1, 비어있음으로 판별
void init_stack(StackType* s) {
	s->top = -1;
}

//스택 비어있는지 확인 (-1인지)
int is_empty(StackType* s) {
	return (s->top == -1);
}

//스택이 꽉 차 있는지 (MAX_STACK_SIZE -1 과 같으면)
int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

//스택에 데이터 삽입
void push(StackType* s, element item) {
	if (is_full(s)) {//꽉 차 있는지 검색
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item; //삽입 후 top 부분 +1
}

//스택 데이터 추출 (맨 위부터)
element pop(StackType* s) {
	if (is_empty(s)) {//공백인지 검색
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];//그냥 맨 위를 아래로)
}

element peek(StackType* s) {
	if (is_empty(s)) {//빈 공간인지 확인
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];//peek는 데이터를 확인함으로 그냥 top 데이터 확인
}

int eval(char exp[]) {
	int op1, op2, value, i = 0;
	int len = strlen(exp);
	char ch;
	StackType s;

	init_stack(&s);
	for (i = 0; i < len; i++) {
		if (exp[i] == ' ') {
			i++;
		}
		ch = exp[i];
		if (ch != '+' && ch != '-' && ch != '*' && ch != '/') {
			int value, j =0;
			char tmp[100];
			while (exp[i] != ' ') {
				tmp[j] = exp[i];
				i++;
				j++;
			}
			tmp[j] = '\0';
			value = atoi(tmp);
			push(&s, value);	
		}
		else {	//연산자이면 피연산자를 스택에서 제거
			op2 = pop(&s);	//연산자는 피연산자가 2개가 있어야 처리 가능하므로..
			op1 = pop(&s);
			switch (ch) { //연산을 수행하고 스택에 저장 
			case '+': push(&s, op1 + op2); break;
			case '-': push(&s, op1 - op2); break;
			case '*': push(&s, op1 * op2); break;
			case '/': push(&s, op1 / op2); break;
			}
		}
	}
	return pop(&s);
}

int main(void) {
	int result;
	printf("후위표기식은 2 200 2 5 * 3 - + *\n");
	result = eval("2 200 2 5 * 3 - + *");
	printf("결과값은 %d\n", result);
	return 0;
}
```
practice 13
```C
#include <stdio.h>

#include <stdlib.h>

  

// ===== 원형큐 코드 시작 ======

#define MAX_QUEUE_SIZE 5

typedef int element;

typedef struct { // 큐 타입

    element  data[MAX_QUEUE_SIZE];

    int  front, rear;

} QueueType;

  

// 오류 함수

void error(char* message){

    fprintf(stderr, "%s\n", message);

    exit(1);

}

  

// 공백 상태 검출 함수

void init_queue(QueueType* q){

    q->front = q->rear = 0;

}

  

// 공백 상태 검출 함수

int is_empty(QueueType* q){

    return (q->front == q->rear);

}

  

// 포화 상태 검출 함수

int is_full(QueueType* q){

    return ((q->rear + 1) % MAX_QUEUE_SIZE == q->front);

}

  

// 원형큐 출력 함수

void queue_print(QueueType* q){

    printf("QUEUE(front=%d rear=%d) = ", q->front, q->rear);

    if (!is_empty(q)) {

        int i = q->front;

        do {

            i = (i + 1) % (MAX_QUEUE_SIZE);

            printf("%d | ", q->data[i]);

            if (i == q->rear)

                break;

        } while (i != q->front);

    }

    printf("\n");

}

  

// 삽입 함수

void enqueue(QueueType* q, element item){

    if (is_full(q))

        error("큐가 포화상태입니다");

    q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;

    q->data[q->rear] = item;

}

  

// 삭제 함수

element dequeue(QueueType* q){

    if (is_empty(q))

        error("큐가 공백상태입니다");

    q->front = (q->front + 1) % MAX_QUEUE_SIZE;

    return q->data[q->front];

}

  

// q의 맨 앞에 있는 데이터 읽기

element peek(QueueType* q){

    if (is_empty(q))

        error("큐가 공백상태입니다");

    return q->data[(q->front+1) % MAX_QUEUE_SIZE];

}

// ===== 원형큐 코드 끝 ======

  

int main(void){

    QueueType queue;

  

    init_queue(&queue);

    enqueue(&queue, 0);

    enqueue(&queue, 1);

    for (int i = 0; i < 13; i++) {

        element e1 = dequeue(&queue);

        element e2 = dequeue(&queue);

        element e3 = e1 + e2;

        printf("%d ", e3);

        enqueue(&queue, e2);    // 큐에 추가한다.

        enqueue(&queue, e3);    // 큐에 추가한다.

    }

    return 0;

}
```
practice 14
```C
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#define MAX_QUEUE_SIZE 10

typedef int element;

typedef struct { // 큐 타입

    element  data[MAX_QUEUE_SIZE];

    int  front, rear;

} DequeType;

void error(char* message) {

    fprintf(stderr, "%s\n", message);

    exit(1);

}

void init_deque(DequeType* q) {

    q->front = q->rear = 0;

}

int is_empty(DequeType* q) {

    return (q->front == q->rear);

}

int is_full(DequeType* q) {

    return ((q->rear + 1) % MAX_QUEUE_SIZE == q->front);

}

void add_rear(DequeType* q, element item) {

    if (is_full(q))

        error("큐가 포화상태입니다");

    q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;

    q->data[q->rear] = item;

}

  

element get_front(DequeType* q) {

    if (is_empty(q))

        error("큐가 공백상태입니다");

    return q->data[(q->front + 1) % MAX_QUEUE_SIZE];

}

  

void deque_print(DequeType* q) {

    printf("DEQUE(front=%d rear=%d) = ", q->front, q->rear);

    if (!is_empty(q)) {

        int i = q->front;

        do {

            i = (i + 1) % (MAX_QUEUE_SIZE);

            printf("%d | ", q->data[i]);

            if (i == q->rear)

                break;

        } while (i != q->front);

    }

    printf("\n");

}

void add_front(DequeType* q, element val) {

    if (is_full(q))

        error("큐가 포화상태입니다");

    q->data[q->front] = val;

    q->front = (q->front - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;

}

element get_rear(DequeType* q) {

    if (is_empty(q))

        error("큐가 공백상태입니다");

    return q->data[q->rear];

}

element delete_rear(DequeType* q) {

    int prev = q->rear;

    if (is_empty(q))

        error("큐가 공백상태입니다");

    q->rear = (q->rear - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;

    return q->data[prev];

}

  

element delete_front(DequeType* q) {

    if (is_empty(q))

        error("큐가 공백상태입니다");

    q->front = (q->front + 1) % MAX_QUEUE_SIZE;

    return q->data[q->front];

}

  

/// get_count

int get_count(DequeType* q) {

    int count = q->rear - q->front;

    if (count < 0) count += MAX_QUEUE_SIZE;

    return count;

}

void main() {

    DequeType queue;

    char string[100];

    printf("문자열을 입력해주세요: ");

    gets_s(string, 100);

  

    init_deque(&queue);

    for (int i = 0; i < strlen(string); i++) {

        add_rear(&queue, string[i]);

    }

    int equal = 1;

  

    while (get_count(&queue) > 1 && equal) {

        char first = delete_front(&queue);

        char last = delete_rear(&queue);

        if (first != last)

            equal = 0;

    }

    if (equal)

        printf("%s 회문", string);

    else

        printf("%s 회문 아님", string);

}
```
practice 15
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef char element;
typedef struct StackNode {
	element data;
	struct StackNode* link;
} StackNode;
typedef struct {
	StackNode* top;
} LinkedStackType;
// 초기화 함수
void init(LinkedStackType* s) {
	s->top = NULL;
}
// 공백 상태 검출 함수
int is_empty(LinkedStackType* s) {
	return (s->top == NULL);
}
// 삽입 함수
void push(LinkedStackType* s, element item) {
	StackNode* temp = (StackNode*)malloc(sizeof(StackNode));
	temp->data = item;
	temp->link = s->top; //현재 위치에 대한 값
	s->top = temp;

}
void print_stack(LinkedStackType* s) {
	for (StackNode* p = s->top; p != NULL; p = p->link) {
		printf("%d", p->data);
	}
}
// 삭제 함수
element pop(LinkedStackType* s) {
	if (!is_empty(s)) {
		exit(1);
	}
	StackNode* temp = s->top;
	element d = temp->data;
	s->top = s->top->link; // temp->link; 넣어도됨
	free(temp);
	return d;
}
int main(void) {
	char name[] = "Kwangseob Kim";
	LinkedStackType s;
	init(&s);
	for (int i = 0; i < strlen(name); i++) {
		push(&s, name[i]);
	}
	while (!is_empty(&s)) {
		printf("%c", pop(&s));
	}
	return 0;
}
```
practice 16
```C
#include <stdio.h>
#include <stdlib.h>
typedef int element;// 요소의 타입
typedef struct QueueNode {// 큐의 노드의 타입
	element data;
	struct QueueNode* link;
} QueueNode;
typedef struct {// 큐 ADT 구현
	QueueNode* front, * rear;
} LinkedQueueType;

void init(LinkedQueueType* q) {
	q->front = q->rear = NULL;
}
int is_empty(LinkedQueueType* q) {
	if (q->front == NULL) {
		return 1;
	}
	else {
		return 0;
	}
}

// 삽입 함수
void enqueue(LinkedQueueType* q, element data) {
	QueueNode* temp = (QueueNode*)malloc(sizeof(QueueNode));
	temp->data = data;
	temp->link = NULL;
	if (is_empty(q)) {
		q->front = q->rear = temp;
	}
	else {
		q->rear->link = temp;
		q->rear = temp;
	}

}
// 삭제 함수
element dequeue(LinkedQueueType* q) {
	QueueNode* temp = q->front;
	if (is_empty(q)) {
		exit(1);
	}
	element d = temp->data;
	q->front = q->front->link;
	free(temp);
	return d;
}

int main(void) {
	LinkedQueueType queue;

	init(&queue);
	enqueue(&queue, 0);
	enqueue(&queue, 1);
	for (int i = 0; i < 13; i++) {
		element e1 = dequeue(&queue);
		element e2 = dequeue(&queue);
		element e3 = e1 + e2;
		printf("%d ", e3);
		enqueue(&queue, e2);	// 큐에 추가한다. 
		enqueue(&queue, e3);	// 큐에 추가한다. 
	}
	return 0;

}
```
