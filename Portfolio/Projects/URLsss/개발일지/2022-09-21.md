serializer는 request와 response의 중계역할이다. model에 바로 저장되게 하는것이 맞으며 serializer를 다른 용도로 사용하면 안됨.
그리고 URLField는 http, https, ftp, ftps 만 검사하므로 scheme_list는 의미 없음.




hsts
To enable:

1.  Have `SecurityMiddleware` installed as above.
2.  Set `SECURE_HSTS_SECONDS` to the number of seconds you want to specify in the header.
3.  Optionally, set `SECURE_HSTS_INCLUDE_SUBDOMAINS` and `SECURE_HSTS_PRELOAD` to `True` to activate their respective flags.
https://blog.jun2.org/development/2019/07/23/django-security-options.html

views.py
```python
from rest_framework import viewsets  
from rest_framework.decorators import api_view  
from urlvalidator.serializers import URLSerializer  
from django.core.validators import URLValidator  
from django.core.exceptions import ValidationError  
from urllib.parse import urlparse  
from urlvalidator.models import models  
  
  
# docs/url/s3 get  
@api_view(["POST"])  
def is_valid_url(input_url) -> bool:  
    # queryset = models.URLField.objects.all()  
    serializer = URLSerializer(data=input_url.data)  
    validator = URLValidator(verify_exists=True)  
    # url = models.URLField(verify_exists=True)  
  
    try:  
        validator(input_url)  
        if input_url.startswith("http" or "ftps"):  
            print(f'url {input_url} start with no secure protocols.')  
        # 받은 URL이 secure이 포함된 프로토콜이 아니라면 경고를 보내줍니다.  
        # url is valid here        # url is valid 인 상태이므로 다음으로 넘겨주면 됩니다  
        # serializer.save()  
        return True  
  
    except ValidationError:  
        print(ValidationError)  
        print(f'This url: {input_url} is not valid. Try another')  
        return False
```